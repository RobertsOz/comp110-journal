# When does a physical system compute?
This paper examines what is a computer and when does it compute. This is a very interesting paper because I feel it is important to know this definition, computers are evolving year by year the machines we had a few years ago are not the ones we have right now. As more time passes it will be harder and harder to distinqush what is a computer and it is important to know when something is computer, because if people don't know how something works we might regress as humanity, thinking everything is magic. The idea behind the paper is that we cannot let ourselves not know how something computes, and trying to find a physical formula to know when something is computing. The modern computer is a currently a very simple thing to understand when it is computing, but the paper goes beyond the modern computer and finds a way to know when an abstract computer is computing using this theorem. 

# Experimental Investigations of the Utility of Detailed Flowcharts in Programming 
This paper examines what is the utility for flowcharts to find how useful they are. The idea behind flowcharts is to simplify the code into something any programmer/reader could understand and then recreate the flowchart back into code. It is like future proofing coding because there are so many programming languages out there today it is impossible to know them all and keep up to date with them. But if you look at a flowchart it uses the same computer logic but displays it in a visually pleasing way. You can literally follow the thread of computation and know how you have to code the program. So it would be great if any flowchart you make would be a perfect representation of code, but that is where the disadvantage of flowcharts come. The flowchart is as good at showing the idea behind the computation as the person making the flowchart. You could give two different people to write a flowchart for the same peace of code and get two different flowcharts. And that is also the conclusion the paper comes to, that flowcharts are not statistically relevant, the person reading it still has to understand what the person making the flowchart meant by something, so he might as well be looking at the raw code. So the more detailed the flowchart the more complex it becomes to understand when you are dealing with large systems it is not useful to be as detailed as possible for the flowchart. If you keep the abstraction high and the flowchart small, it will convey the idea of the code better, but the question still becomes will that be helpful to recreate the code. And I think it will a flowchart should be used as roadmap with key points not a blueprint to recreate every single pathway.

# A Fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space 
This paper examines how to calculate when a 3D object is colliding or near to some other object. When calculating 2d objects it is fairly simple to know when they collide because it is a single vector from A to B, but when you go into a three dimensional space everything gets more complicated. The shortest distance between two points on a 3d object would represent a simmilar alogrithm for a 2d space. But a computer doesn't know what shortest means in a 3d space you have to figure it out based on both of the models positions and then calculating where each of the points is located at in the 3d space so they can be compared against each other. But this is only with two objects the more objects you would introduce the more complex everything becomes. That is why the paper is trying to find a way to standardize this computation, to make it simple for the future of 3d collisions.

# Go To Statement Considered Harmful
This paper examines the harmfulness of the go to statement and proposes it be removed from use in all higher level languages. The idea behind the paper was that the go to statement was becoming obsolete with the introduction of while loops and if statements. And programmers were using go to statements as a cruch either not wanting to transition to a better way or not wanting to understand the better way. When using a go to statement it made the code harder to read because a go to can jump around the code with no rules. It was also harder to tell where a current program was in code due to the nature of the go to statement. It is important to step back and realise when something could be done better and go away from using something safe to using something reliable. We as programmers have to look out for cases like these, we could set precident in writing code that works alright without thinking if this code will be reused/repurposed down the line.

# What connects these papers?
All these papers are thinking about the future of computing and programming, the idea that technology wont stay on a plateu and it is always evolving and growing and that is why we have to keep up to date with where it is going and think of ways to make it easier for ourselves and others in that future. When thinking of a solution it has to work with the technology that is out there now and potential technology that will be created, or at the very least make it easier to transition the old tech to new tech.
